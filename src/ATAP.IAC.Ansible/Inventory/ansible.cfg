# File name: ansible.cfg
# File path: /etc/ansible/ansible.cfg

[defaults]

# (pathlist) Comma separated list of Ansible inventory sources
inventory=/etc/ansible/hosts.yml

# (string) This indicates the command to use to spawn a shell under for Ansible's execution needs on a target. Users may need to change this in rare instances when shell usage is constrained, but in most cases it may be left as is.
executable=pwsh # out of box value is /bin/sh  # should be the location of Powershel V5 (Desktop) or Powershell V7 (Core) if the target is a Windows host

# (string) Temporary directory to use on targets when executing tasks.
remote_tmp=D:\Temp #/~/.ansible/tmp

# (list) Check all of these extensions when looking for 'variable' files which should be YAML or JSON or vaulted versions of these.
# This affects vars_files, include_vars, inventory and vars plugins among others.
yaml_valid_extensions=.yml, .yaml, .json

# (boolean) Toggle Ansible's display and logging of task details, mainly used to avoid security disclosures.
;no_log=False

# (path) The default root path for Ansible config files on the controller.
;home=~/.ansible # out of box location is /etc/ansible

# (boolean) This controls whether an Ansible playbook should prompt for a vault password.
;ask_vault_pass=False

# (path) The password file to use for the connection plugin. --connection-password-file.
;connection_password_file=

# (path) The password file to use for the become plugin. --become-password-file.
# If executable, it will be run and the resulting stdout will be used as the password.
;become_password_file=

# (list) List of logger names to filter out of the log file
;log_filter=

# (path) File to which Ansible will log on the controller. When empty logging is disabled.
;log_path=

# (boolean) Toggle Ansible logging to syslog on the target when it executes tasks. On Windows hosts this will disable a newer style PowerShell modules from writing to the event log.
;no_target_syslog=False

# (pathspec) Colon separated paths in which Ansible will search for Become Plugins.
;become_plugins={{ ANSIBLE_HOME ~ "/plugins/become:/usr/share/ansible/plugins/become" }}

# (pathspec) Colon separated paths in which Ansible will search for collections content. Collections must be in nested *subdirectories*, not directly in these directories. For example, if ``COLLECTIONS_PATHS`` includes ``'{{ ANSIBLE_HOME ~ "/collections" }}'``, and you want to add ``my.collection`` to that directory, it must be saved as ``'{{ ANSIBLE_HOME} ~ "/collections/ansible_collections/my/collection" }}'``.
;collections_path={{ ANSIBLE_HOME ~ "/collections:/usr/share/ansible/collections" }}

# (pathspec) Colon separated paths in which Ansible will search for Action Plugins.
;action_plugins={{ ANSIBLE_HOME ~ "/plugins/action:/usr/share/ansible/plugins/action" }}

# (pathspec) Colon separated paths in which Ansible will search for Cache Plugins.
;cache_plugins={{ ANSIBLE_HOME ~ "/plugins/cache:/usr/share/ansible/plugins/cache" }}

# (pathspec) Colon separated paths in which Ansible will search for Callback Plugins.
;callback_plugins={{ ANSIBLE_HOME ~ "/plugins/callback:/usr/share/ansible/plugins/callback" }}

# (pathspec) Colon separated paths in which Ansible will search for Cliconf Plugins.
;cliconf_plugins={{ ANSIBLE_HOME ~ "/plugins/cliconf:/usr/share/ansible/plugins/cliconf" }}

# (pathspec) Colon separated paths in which Ansible will search for Connection Plugins.
;connection_plugins={{ ANSIBLE_HOME ~ "/plugins/connection:/usr/share/ansible/plugins/connection" }}

# (pathspec) Colon separated paths in which Ansible will search for Jinja2 Filter Plugins.
;filter_plugins={{ ANSIBLE_HOME ~ "/plugins/filter:/usr/share/ansible/plugins/filter" }}

# (pathspec) Colon separated paths in which Ansible will search for Lookup Plugins.
;lookup_plugins={{ ANSIBLE_HOME ~ "/plugins/lookup:/usr/share/ansible/plugins/lookup" }}

# (pathspec) Colon separated paths in which Ansible will search for Modules.
;library={{ ANSIBLE_HOME ~ "/plugins/modules:/usr/share/ansible/plugins/modules" }}

# (pathspec) Colon separated paths in which Ansible will search for Module utils files, which are shared by modules.
;module_utils={{ ANSIBLE_HOME ~ "/plugins/module_utils:/usr/share/ansible/plugins/module_utils" }}

# (pathspec) Colon separated paths in which Ansible will search for Netconf Plugins.
;netconf_plugins={{ ANSIBLE_HOME ~ "/plugins/netconf:/usr/share/ansible/plugins/netconf" }}

# (pathspec) Colon separated paths in which Ansible will search for Roles.
;roles_path={{ ANSIBLE_HOME ~ "/roles:/usr/share/ansible/roles:/etc/ansible/roles" }}

# (pathspec) Colon separated paths in which Ansible will search for Strategy Plugins.
;strategy_plugins={{ ANSIBLE_HOME ~ "/plugins/strategy:/usr/share/ansible/plugins/strategy" }}

# (pathspec) Colon separated paths in which Ansible will search for Terminal Plugins.
;terminal_plugins={{ ANSIBLE_HOME ~ "/plugins/terminal:/usr/share/ansible/plugins/terminal" }}

# (pathspec) Colon separated paths in which Ansible will search for Jinja2 Test Plugins.
;test_plugins={{ ANSIBLE_HOME ~ "/plugins/test:/usr/share/ansible/plugins/test" }}

# (pathspec) Colon separated paths in which Ansible will search for Vars Plugins.
;vars_plugins={{ ANSIBLE_HOME ~ "/plugins/vars:/usr/share/ansible/plugins/vars" }}

# (pathspec) Colon separated paths in which Ansible will search for Documentation Fragments Plugins.
;doc_fragment_plugins={{ ANSIBLE_HOME ~ "/plugins/doc_fragments:/usr/share/ansible/plugins/doc_fragments" }}


# (string) The vault_id to use for encrypting by default. If multiple vault_ids are provided, this specifies which to use for encryption. The --encrypt-vault-id cli option overrides the configured value.
;vault_encrypt_identity=

# (string) The label to use for the default vault id label in cases where a vault id label is not provided
;vault_identity=default

# (list) A list of vault-ids to use by default. Equivalent to multiple --vault-id args. Vault-ids are tried in order.
;vault_identity_list=

# (string) If true, decrypting vaults with a vault id will only try the password from the matching vault-id
;vault_id_match=False

# (path) The vault password file to use. Equivalent to --vault-password-file or --vault-id
# If executable, it will be run and the resulting stdout will be used as the password.
;vault_password_file=

# (boolean) Normally ``ansible-playbook`` will print a header for each task that is run. These headers will contain the name: field from the task if you specified one. If you didn't then ``ansible-playbook`` uses the task's action to help you tell which task is presently running. Sometimes you run many of the same action and so you want more information about the task to differentiate it from others of the same action. If you set this variable to True in the config then ``ansible-playbook`` will also include the task's arguments in the header.
# This setting defaults to False because there is a chance that you have sensitive values in your parameters and you do not want those to be printed.
# If you set this to True you should be sure that you have secured your environment's stdout (no one can shoulder surf your screen and you aren't saving stdout to an insecure file) or made sure that all of your playbooks explicitly added the ``no_log: True`` parameter to tasks which have sensitive values See How do I keep secret data in my playbook? for more information.
;display_args_to_stdout=False

# (boolean) Whether or not to enable the task debugger, this previously was done as a strategy plugin.
# Now all strategy plugins can inherit this behavior. The debugger defaults to activating when
# a task is failed on unreachable. Use the debugger keyword for more flexibility.
;enable_task_debugger=False


# (boolean) Facts are available inside the `ansible_facts` variable, this setting also pushes them as their own vars in the main namespace.
# Unlike inside the `ansible_facts` dictionary, these will have an `ansible_` prefix.
;inject_facts_as_vars=True

# (string) Path to the Python interpreter to be used for module execution on remote targets, or an automatic discovery mode. Supported discovery modes are ``auto`` (the default), ``auto_silent``, ``auto_legacy``, and ``auto_legacy_silent``. All discovery modes employ a lookup table to use the included system Python (on distributions known to include one), falling back to a fixed ordered list of well-known Python interpreter locations if a platform-specific default is not available. The fallback behavior will issue a warning that the interpreter should be set explicitly (since interpreters installed later may change which one is used). This warning behavior can be disabled by setting ``auto_silent`` or ``auto_legacy_silent``. The value of ``auto_legacy`` provides all the same behavior, but for backwards-compatibility with older Ansible releases that always defaulted to ``/usr/bin/python``, will use that interpreter if present.
;interpreter_python=auto

# (bool) Configure the result format to be more readable
# When the result format is set to C(yaml) this option defaults to C(True), and defaults to C(False) when configured to C(json).
# Setting this option to C(True) will force C(json) and C(yaml) results to always be pretty printed regardless of verbosity.
# When set to C(True) and used with the C(yaml) result format, this option will modify module responses in an attempt to produce a more human friendly output at the expense of correctness, and should not be relied upon to aid in writing variable manipulations or conditionals. For correctness, set this option to C(False) or set the result format to C(json).
;callback_format_pretty=

# (list) list of users to be expected to have admin privileges. This is used by the controller to determine how to share temporary files between the remote user and the become user.
;admin_users=root, toor

# (string) Directory in which ansible will keep async job information
;async_dir=~/.ansible_async

# (list) List of valid system temporary directories on the managed machine for Ansible to validate C(remote_tmp) against, when specific permissions are needed.  These must be world readable, writable, and executable. This list should only contain directories which the system administrator has pre-created with the proper ownership and permissions otherwise security issues can arise.
# When C(remote_tmp) is required to be a system temp dir and it does not match any in the list, the first one from the list will be used instead.
;system_tmpdirs=/var/tmp, /tmp

# (boolean) This makes the temporary files created on the machine world-readable and will issue a warning instead of failing the task.
# It is useful when becoming an unprivileged user.
;allow_world_readable_tmpfiles=False


[privilege_escalation]
# (string) Privilege escalation method to use when `become` is enabled.
become_method=runas

# (boolean) Toggles the use of privilege escalation, allowing you to 'become' another user after login.
become=True

# (boolean) Display an agnostic become prompt instead of displaying a prompt containing the command line supplied become method
;agnostic_become_prompt=True

# (boolean) This setting controls if become is skipped when remote user and become user are the same. I.E root sudo to root.
# If executable, it will be run and the resulting stdout will be used as the password.
;become_allow_same_user=False

# (boolean) Toggle to prompt for privilege escalation password.
;become_ask_pass=False

# (string) executable to use for privilege escalation, otherwise Ansible will depend on PATH
;become_exe=

# (string) Flags to pass to the privilege escalation executable.
;become_flags=

# (string) The user your login/remote user 'becomes' when using privilege escalation, most systems will use 'root' when no user is specified.
;become_user=root

[persistent_connection]
# (path) Specify where to look for the ansible-connection script. This location will be checked before searching $PATH.
# If null, ansible will start with the same directory as the ansible script.
;ansible_connection_path=

# (int) This controls the amount of time to wait for response from remote device before timing out persistent connection.
;command_timeout=30

# (integer) This controls the retry timeout for persistent connection to connect to the local domain socket.
;connect_retry_timeout=15

# (integer) This controls how long the persistent connection will remain idle before it is destroyed.
;connect_timeout=30

# (path) Path to socket to be used by the connection persistence system.
;control_path_dir={{ ANSIBLE_HOME ~ "/pc" }}


[connection]
# (boolean) This is a global option, each connection plugin can override either by having more specific options or not supporting pipelining at all.
# Pipelining, if supported by the connection plugin, reduces the number of network operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfer.
# It can result in a very significant performance improvement when enabled.
# However this conflicts with privilege escalation (become). For example, when using 'sudo:' operations you must first disable 'requiretty' in /etc/sudoers on all managed hosts, which is why it is disabled by default.
# This setting will be disabled if ``ANSIBLE_KEEP_REMOTE_FILES`` is enabled.
;pipelining=False

# (boolean) Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.
# This can result in a very significant performance improvement when enabled.
# However this can conflict with privilege escalation (become). For example, when using sudo operations you must first disable 'requiretty' in the sudoers file for the target hosts, which is why this feature is disabled by default.
;pipelining=False

# (boolean) Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.
# This can result in a very significant performance improvement when enabled.
# However this can conflict with privilege escalation (become). For example, when using sudo operations you must first disable 'requiretty' in the sudoers file for the target hosts, which is why this feature is disabled by default.
;pipelining=False

# (boolean) Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.
# This can result in a very significant performance improvement when enabled.
# However this can conflict with privilege escalation (become). For example, when using sudo operations you must first disable 'requiretty' in the sudoers file for the target hosts, which is why this feature is disabled by default.
;pipelining=False


[colors]
# (string) Defines the color to use on 'Changed' task status
;changed=yellow

# (string) Defines the default color to use for ansible-console
;console_prompt=white

# (string) Defines the color to use when emitting debug messages
;debug=dark gray

# (string) Defines the color to use when emitting deprecation messages
;deprecate=purple

# (string) Defines the color to use when showing added lines in diffs
;diff_add=green

# (string) Defines the color to use when showing diffs
;diff_lines=cyan

# (string) Defines the color to use when showing removed lines in diffs
;diff_remove=red

# (string) Defines the color to use when emitting error messages
;error=red

# (string) Defines the color to use for highlighting
;highlight=white

# (string) Defines the color to use when showing 'OK' task status
;ok=green

# (string) Defines the color to use when showing 'Skipped' task status
;skip=cyan

# (string) Defines the color to use on 'Unreachable' status
;unreachable=bright red

# (string) Defines the color to use when emitting verbose messages. i.e those that show with '-v's.
;verbose=blue

# (string) Defines the color to use when emitting warning messages
;warn=bright purple


[diff]
# (bool) Configuration toggle to tell modules to show differences when in 'changed' status, equivalent to ``--diff``.
;always=False

# (integer) How many lines of context to show when displaying the differences between files.
;context=3


[galaxy]
# (path) The directory that stores cached responses from a Galaxy server.
# This is only used by the ``ansible-galaxy collection install`` and ``download`` commands.
# Cache files inside this dir will be ignored if they are world writable.
;cache_dir={{ ANSIBLE_HOME ~ "/galaxy_cache" }}

# (path) Collection skeleton directory to use as a template for the ``init`` action in ``ansible-galaxy collection``, same as ``--collection-skeleton``.
;collection_skeleton=

# (list) patterns of files to ignore inside a Galaxy collection skeleton directory
;collection_skeleton_ignore=^.git$, ^.*/.git_keep$

# (bool) Disable GPG signature verification during collection installation.
;disable_gpg_verify=False

# (bool) Some steps in ``ansible-galaxy`` display a progress wheel which can cause issues on certain displays or when outputing the stdout to a file.
# This config option controls whether the display wheel is shown or not.
# The default is to show the display wheel if stdout has a tty.
;display_progress=

# (path) Configure the keyring used for GPG signature verification during collection installation and verification.
;gpg_keyring=

# (boolean) If set to yes, ansible-galaxy will not validate TLS certificates. This can be useful for testing against a server with a self-signed certificate.
;ignore_certs=

# (list) A list of GPG status codes to ignore during GPG signature verification. See L(https://github.com/gpg/gnupg/blob/master/doc/DETAILS#general-status-codes) for status code descriptions.
# If fewer signatures successfully verify the collection than `GALAXY_REQUIRED_VALID_SIGNATURE_COUNT`, signature verification will fail even if all error codes are ignored.
;ignore_signature_status_codes=

# (str) The number of signatures that must be successful during GPG signature verification while installing or verifying collections.
# This should be a positive integer or all to indicate all signatures must successfully validate the collection.
# Prepend + to the value to fail if no valid signatures are found for the collection.
;required_valid_signature_count=1

# (path) Role skeleton directory to use as a template for the ``init`` action in ``ansible-galaxy``/``ansible-galaxy role``, same as ``--role-skeleton``.
;role_skeleton=

# (list) patterns of files to ignore inside a Galaxy role or collection skeleton directory
;role_skeleton_ignore=^.git$, ^.*/.git_keep$

# (string) URL to prepend when roles don't specify the full URI, assume they are referencing this server as the source.
;server=https://galaxy.ansible.com

# (list) A list of Galaxy servers to use when installing a collection.
# The value corresponds to the config ini header ``[galaxy_server.{{item}}]`` which defines the server details.
# See :ref:`galaxy_server_config` for more details on how to define a Galaxy server.
# The order of servers in this list is used to as the order in which a collection is resolved.
# Setting this config option will ignore the :ref:`galaxy_server` config option.
;server_list=

# (path) Local path to galaxy access token file
;token_path={{ ANSIBLE_HOME ~ "/galaxy_token" }}


[inventory]
# (list) List of enabled inventory plugins, it also determines the order in which they are used.
enable_plugins=yaml, host_list, script, auto, ini, toml

# (string) This setting changes the behaviour of mismatched host patterns, it allows you to force a fatal error, a warning or just ignore it
;host_pattern_mismatch=warning

# (boolean) If 'true', it is a fatal error when any given inventory source cannot be successfully parsed by any available inventory plugin; otherwise, this situation only attracts a warning.
;any_unparsed_is_failed=False



# (bool) Controls if ansible-inventory will accurately reflect Ansible's view into inventory or its optimized for exporting.
;export=False

# (list) List of extensions to ignore when using a directory as an inventory source
;ignore_extensions={{(REJECT_EXTS + ('.orig', '.ini', '.cfg', '.retry'))}}

# (list) List of patterns to ignore when using a directory as an inventory source
;ignore_patterns=

# (bool) If 'true' it is a fatal error if every single potential inventory source fails to parse, otherwise this situation will only attract a warning.
;unparsed_is_failed=False

# (boolean) By default Ansible will issue a warning when no inventory was loaded and notes that it will use an implicit localhost-only inventory.
# These warnings can be silenced by adjusting this setting to False.
;inventory_unparsed_warning=True



[runas_become_plugin]
# (string) Options to pass to runas, a space delimited list of k=v pairs
;flags=

# (string) password
;password=

# (string) User you 'become' to execute the task
;user=




[ssh_connection]
# (boolean) Determines if SSH should check host keys.
;host_key_checking=True

# (boolean) Pipelining reduces the number of connection operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfers.
# This can result in a very significant performance improvement when enabled.
# However this can conflict with privilege escalation (become). For example, when using sudo operations you must first disable 'requiretty' in the sudoers file for the target hosts, which is why this feature is disabled by default.
;pipelining=False

# (string) This defines the location of the scp binary. It defaults to C(scp) which will use the first binary available in $PATH.
;scp_executable=scp


[winrm]
# (list) A list of environment variables to pass through to C(kinit) when getting the Kerberos authentication ticket.
# By default no environment variables are passed through and C(kinit) is run with a blank slate.
# The environment variable C(KRB5CCNAME) cannot be specified here as it's used to store the temp Kerberos ticket used by WinRM.
;kinit_env_vars=


[inventory_plugins]
# (bool) Merge extra vars into the available variables for composition (highest precedence).
;use_extra_vars=False


[inventory_plugin_script]
# (boolean) Toggle display of stderr even when script was successful
;always_show_stderr=True


[inventory_plugin_yaml]
# (list) list of 'valid' extensions for files containing YAML
;yaml_valid_extensions=.yaml, .yml, .json



[powershell]
# (string) Directory in which ansible will keep async job information.
# Before Ansible 2.8, this was set to C(remote_tmp + "\.ansible_async").
;async_dir=%USERPROFILE%\.ansible_async

# (string) Temporary directory to use on targets when copying files to the host.
remote_tmp=D:\Temp

# (string) Directory i
[vars_host_group_vars]
# (str) Control when this vars plugin may be executed.
# Setting this option to C(all) will run the vars plugin after importing inventory and whenever it is demanded by a task.
# Setting this option to C(task) will only run the vars plugin whenever it is demanded by a task.
# Setting this option to C(inventory) will only run the vars plugin after parsing inventory.
# If this option is omitted, the global I(RUN_VARS_PLUGINS) configuration is used to determine when to execute the vars plugin.
;stage=

