using System;
using System.Collections.Generic;
using System.Text;


//there are actually two namespaces in this .cs (VATestPlugin, VATestWinampPlugin... see way down below) and each contain a class that would be considered a, 'plugin' (since each contain the necessary static functions to be a VoiceAttack plugin)

namespace AOEPlugin
{

    public class VoiceAttackAOEPlugin
    {
        //NOTE THAT THIS IS A SAMPLE CLASS AND IS NOT FOR ANY MEANINGFUL USE.
        //You will want to gut this completely if you plan on using it... lol

        public static string VA_DisplayName()
        {
            return "Age Of Empires Plugin V0.1.0-alpha";  //this is wdisplayed in dropdowns as well as in the log file to indicate the name of the plugin
        }

        public static string VA_DisplayInfo()
        {
            return "Age Of Empires Plugin\r\n\r\nThis is just a sample.\r\n\r\n2016 VoiceAttack";  //this is  extended info that you might want to give to the user.  note that you should format this up properly.
        }

        public static Guid VA_Id()
        {
            return new Guid("{C16BEBA9-2003-4b7f-BFA2-55B7C607925B}");  //this id must be generated by YOU... it must be unique so VoiceAttack can identify and use the plugin
        }

        static Boolean _stopVariableToMonitor = false;

        //this function is called from VoiceAttack when the 'stop all commands' button is pressed or a, 'stop all commands' action is called.  this will help you know if processing needs to stop if you have long-running code
        public static void VA_StopCommand()
        {
            _stopVariableToMonitor = true;
        }


        //note that in this version of the plugin interface, there is only a single dynamic parameter.  All the functionality of the previous parameters can be found in vaProxy
        public static void VA_Init1(dynamic vaProxy)
        {
            //this is where you can set up whatever session information that you want.  this will only be called once on voiceattack load, and it is called asynchronously.
            //the SessionState property is a local copy of the state held on to by VoiceAttack.  In this case, the state will be a dictionary with zero items.  You can add as many items to hold on to as you want.
            //note that in this version, you can get and set the VoiceAttack variables directly.


            vaProxy.SessionState.Add("new state value", 369);  //set whatever private state information you want to maintain (note this is a dictionary of (string, object)
            vaProxy.SessionState.Add("second new state value", "hello");

            vaProxy.SetSmallInt("initializedCondition1", 1);  //set some meaningless example short integers (used to be called, 'conditions')
            vaProxy.SetSmallInt("initializedCondition2", 2);

            vaProxy.SetText("initializedText1", "This is 1");  //set some meaningless example text values
            vaProxy.SetText("initializedText2", "This is 2");

            vaProxy.SetInt("initializedInt1", 55);  //set some meaningless example integer values
            vaProxy.SetInt("initializedInt2", 77);

            vaProxy.SetDecimal("initializedDecimal1", 44.2m);  //set some meaningless example decimal values
            vaProxy.SetDecimal("initializedDecimal2", -99.9m);

            vaProxy.SetBoolean("initializedBoolean1", true);  //set some meaningless example boolean values
            vaProxy.SetBoolean("initializedBoolean2", false);

        }

        public static void VA_Exit1(dynamic vaProxy)
        {
            //this function gets called when VoiceAttack is closing (normally).  You would put your cleanup code in here, but be aware that your code must be robust enough to not absolutely depend on this function being called
            if (vaProxy.SessionState.ContainsKey("myStateValue"))  //the sessionstate property is a dictionary of (string, object)
            {
                //do some kind of file cleanup or whatever at this point
            }
        }

        public static void VA_Invoke1(dynamic vaProxy)
        {
            //This function is where you will do all of your work.  When VoiceAttack encounters an, 'Execute External Plugin Function' action, the plugin indicated will be called.
            //in previous versions, you were presented with a long list of parameters you could use.  The parameters have been consolidated in to one dynamic, 'vaProxy' parameter.

            //vaProxy.Context - a string that can be anything you want it to be.  this is passed in from the command action.  this was added to allow you to just pass a value into the plugin in a simple fashion (without having to set conditions/text values beforehand).  Convert the string to whatever type you need to.

            //vaProxy.SessionState - all values from the state maintained by VoiceAttack for this plugin.  the state allows you to maintain kind of a, 'session' within VoiceAttack.  this value is not persisted to disk and will be erased on restart. other plugins do not have access to this state (private to the plugin)

            //the SessionState dictionary is the complete state.  you can manipulate it however you want, the whole thing will be copied back and replace what VoiceAttack is holding on to


            //the following get and set the various types of variables in VoiceAttack.  note that any of these are nullable (can be null and can be set to null).  in previous versions of this interface, these were represented by a series of dictionaries

            //vaProxy.SetSmallInt and vaProxy.GetSmallInt - use to access short integer values (used to be called, 'conditions')
            //vaProxy.SetText and vaProxy.GetText - access text variable values
            //vaProxy.SetInt and vaProxy.GetInt - access integer variable values
            //vaProxy.SetDecimal and vaProxy.GetDecimal - access decimal variable values
            //vaProxy.SetBoolean and vaProxy.GetBoolean - access boolean variable values
            //vaProxy.SetDate and vaProxy.GetDate - access date/time variable values

            //to indicate to VoiceAttack that you would like a variable removed, simply set it to null.  all variables set here can be used withing VoiceAttack.
            //note that the variables are global (for now) and can be accessed by anyone, so be mindful of that while naming


            //if the, 'Execute External Plugin Function' command action has the, 'wait for return' flag set, VoiceAttack will wait until this function completes so that you may check condition values and
            //have VoiceAttack react accordingly.  otherwise, VoiceAttack fires and forgets and doesn't hang out for extra processing.


            //below is just some sample code showing how to work with vaProxy.  There's more in the VoiceAttack help documentation that is installed with VoiceAttack (VoiceAttackHelp.pdf).

            if (vaProxy.GetText("myCSharpTestValue") != null) //was the text value passed set?
            {
                vaProxy.SetText("myCSharpTestValue", "hello " + new Random().Next(1, 6).ToString()); //if the value is not null, this is a subsequent call... just change up the value to nonsense.  this value will go back to VoiceAttack (perhaps to be read with TTS or whatever)
            }
            else //value has not been set.  set it here
            {
                vaProxy.SetText("myCSharpTestValue", "this is new");
            }

            short? testShort = vaProxy.GetSmallInt("someValueIWantToClear");  //note that we are using short? (nullable short) in case the value is null
            if (testShort.HasValue)
            {
                vaProxy.SetSmallInt("someValueIWantToClear", null);  //setting the value to null tells VoiceAttack that you want the variable removed
            }

            //here we check the context to see if we should perform an action (with some additional examples of what can be done with vaProxy
            if (vaProxy.Context == "fire weapons")
            {
                if (vaProxy.CommandExists("secret weapon"))  //check if a command exists
                {
                    if (vaProxy.ParseTokens("{ACTIVEWINDOWTITLE}") == "My Awesome Game")  //check the active window title using the parsetokens function
                    {
                        vaProxy.ExecuteCommand("secret weapon");  //this tells VoiceAttack to execute the, 'secret weapon' command by name (if the command exists
                    }
                    else
                    {
                        vaProxy.WriteToLog("Your game was not active and on top.", "purple");
                    }
                }
                else
                {
                    vaProxy.WriteToLog("the secret weapon command does not exist.  you deleted it, didn't you?", "orange");
                }
            }

            //here we are adding some stuff to state
            object objValue = null;
            String strStateValue = null;
            if (vaProxy.SessionState.TryGetValue("myStateValue", out objValue))  //we check to see if there is a value in state for 'myStateValue'
            {
                strStateValue = (String)objValue; //if we find something, we are going to cast it as a string and use it somewhere in here...
            }
            else
                strStateValue = "initialized";  //nothing was found in state... just set the string to, 'initialized' and keep moving...

            //hope that helps some!
        }
    }
}


//this is the second namespace.  both classes could have been in the same namespace.  this is just an example.
namespace VATestWinampPlugin
{
    //this is a very basic plugin created very quickly (maybe 20 minutes, including the profile).  Note that this class depends on the WinampLib.cs file also located in this project.

    //also note that you'll need a running instance of winamp to actually see anything happen... pick a good song and play it while you are issuing voice commands

    public class VoiceAttackSampleWinampPlugin
    {
        public static string VA_DisplayName()
        {
            return "VoiceAttack Simple Winamp Plugin";  //a name to distinguish my plugin from others
        }

        public static Guid VA_Id()
        {
            return new Guid("{99845215-1FF8-4e36-A370-87178D01C7B4}");   //note this is a new guid for this plugin
        }

        public static string VA_DisplayInfo()
        {
            return "VoiceAttack Winamp Sample Plugin\r\n\r\nThis is just a sample to show how VoiceAttack can interact with Winamp.\r\n\r\n2014 VoiceAttack";  //this is just extended info that you might want to give to the user.  note that you should format this up properly.
        }

        public static void VA_Init1(dynamic vaProxy)
        {
            //not needing to initialize anything here this time
        }

        public static void VA_Exit1(dynamic vaProxy)
        {
            //no need to do anything on exit with this implementation
        }

        public static void VA_StopCommand()
        {
            //no need to monitor this
        }

        public static void VA_Invoke1(dynamic vaProxy)
        {

            //NOTE : In this example we could have more easily set the context value, but the illustration is in showing how variables can be accessed through vaProxy

            //see if the vaSampleWinampeCommand short int value exists and has a value.  note that in the included Winamp profile, vaSampleWinampleCommand is being set to a certain value, depending on the command.  if vaSampleWinampeCommand is set to 1, this means, 'play'.  2 means, 'pause', 3 means, 'stop' and so on.
            Int16 iVal = vaProxy.GetSmallInt("vaSampleWinampCommand") ?? 0;  //note that this is a nullable int16... that means that the value can be int16 or null.  we use ?? to default to 0 if the value is null

            switch (iVal) //based on what is passed in, we just call out to the winamp library to make things happen.
            {
                case 1:
                    WinampFrontEndLib.WinampLib.Play();
                    break;
                case 2:
                    WinampFrontEndLib.WinampLib.Pause();
                    break;
                case 3:
                    WinampFrontEndLib.WinampLib.Stop();
                    break;
                case 4:
                    WinampFrontEndLib.WinampLib.VolumeUp();
                    break;
                case 5:
                    WinampFrontEndLib.WinampLib.VolumeDown();
                    break;
                case 6:  //set the volume to a value from 0 to 255
                    Int16? iVolume = vaProxy.GetSmallInt("vaSampleWinampVolume");
                    if (iVolume.HasValue)
                        WinampFrontEndLib.WinampLib.SetVolume(iVolume.Value);  //iVolume can be null at this point
                    break;
                case 7:
                    WinampFrontEndLib.WinampLib.NextTrack();
                    break;
                case 8:
                    WinampFrontEndLib.WinampLib.PrevTrack();
                    break;
                case 9:  //this gets the the current song title and sends it back to VA in a text variable.  in the included winamp profile, you will notice that the title that is sent back is read using text-to-speech

                    vaProxy.SetText("vaSampleWinampTextTitle", WinampFrontEndLib.WinampLib.GetCurrentSongTitle());

                    break;
                default:  //the catch-all for this is to just bail out (undefined or null or whatever)
                    break;
            }

        }
    }
}


