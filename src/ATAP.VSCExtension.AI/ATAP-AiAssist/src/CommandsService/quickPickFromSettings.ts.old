import { LogLevel, ILogger } from '@Logger/index';
import { GUID, Int, IDType } from '@IDTypes/index';
import {
  ItemWithIDValueType,
  ItemWithIDTypes,
  MapTypeToValueType,
  YamlData,
  fromYamlForItemWithID,
  IItemWithID,
  ItemWithID,
  ICollection,
  Collection,
  IFactory,
  Factory,
  ICollectionFactory,
  CollectionFactory,
  TagValueType,
  ITag,
  Tag,
  ITagCollection,
  TagCollection,
  CategoryValueType,
  ICategory,
  Category,
  ICategoryCollection,
  CategoryCollection,
  TokenValueType,
  IToken,
  Token,
  ITokenCollection,
  TokenCollection,
  AssociationValueType,
  IAssociation,
  Association,
  IAssociationCollection,
  AssociationCollection,
  QueryContextValueType,
  IQueryContext,
  QueryContext,
  IQueryContextCollection,
  QueryContextCollection,
} from '@ItemWithIDs/index';


// import { createTypeInstance } from '@TypeMap/index';

import * as vscode from 'vscode';

export async function quickPickFromSettings(
  logger: ILogger,
  setting: string,
): Promise<{
  success: boolean;
  pick: ICollection | IItemWithID | null;
  errorMessage: string | null;
}> {
  let message: string = `starting commandID quickPickFromSettings, setting is ${setting}`;
  logger.log(message, LogLevel.Debug);

  // Retrieve the latest settings directly within the command to ensure the most current values
  const config = vscode.workspace.getConfiguration('ATAP-AiAssist');
  const settingStr: string | undefined = config.get(setting);
  if (!settingStr || settingStr.length === 0) {
    message = `No string found in atap-aiassist ${setting}`;
    logger.log(message, LogLevel.Error);
    return {
      success: false,
      pick: null,
      errorMessage: message,
    };
  }

  const itemWithIDcollection = ItemWithIDCollection.convertFrom_json(settingStr);
  if (!itemWithIDcollection.itemWithIDs || itemWithIDcollection.itemWithIDs.length === 0) {
    message = `Could not convert to a ItemWithIDCollection instance from atap-aiassist ${setting} : ${settingStr}`;
    logger.log(message, LogLevel.Error);
    return {
      success: false,
      pick: null,
      errorMessage: message,
    };
  }

  itemWithIDcollection.itemWithIDs.map((object) => object.value);
  const optionsArray: string[] = ['placeholder1','placeholder2']; //itemWithIDcollection.itemWithIDs.map((object) => object.value);
  if (!optionsArray || optionsArray.length === 0) {
    message = `Could not convert the itemWithIDcollection.items to an optionsArray of strings`;
    logger.log(message, LogLevel.Error);
    return {
      success: false,
      pick: null,
      errorMessage: message,
    };
  }

  // Show QuickPick with the options from settings
  const pickedName = await vscode.window.showQuickPick(optionsArray, {
    placeHolder: 'Select an option',
  });

  // Get the index of name in the name array
  // use that index to get the correct substring from the json that describes the Item
  //
  //   store it into the global's user state (LastPicked)
  // import {data} from
  // message = `data instance ID ${data.instanceID} ; Version ${data.version} `;
  // logger.log(message, LogLevel.Debug);
  // data.Item.{ subtype } =
  if (pickedName !== undefined) {
    // ToDo:pick is just the name, get the entire Item / Collection instance
    // const pickedItem = createTypeInstance<T, settingStr>(settingStr); // ToDo: Fix: maybe use the typemap

    return {
      success: true,
      pick: null, // pickedItem,
      errorMessage: null,
    };
  } else {
    message = 'Quick Pick was canceled';
    return {
      success: false,
      pick: null,
      errorMessage: message,
    };
  }
}
