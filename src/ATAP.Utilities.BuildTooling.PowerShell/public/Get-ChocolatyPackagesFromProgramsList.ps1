
#region Get-ChocolatyPackagesFromProgramsList
<#
.SYNOPSIS
ToDo: write Help SYNOPSIS For this function
.DESCRIPTION
ToDo: write Help DESCRIPTION For this function
.PARAMETER  ModuleName
  Specifies the path to the Powershell Manifest file (.psd1)
.PARAMETER ProductionOnly
  Specifies the path to the directroy where the .nuspec file will be written

.PARAMETER Extension
ToDo: write Help For the parameter X
.INPUTS
ToDo: write Help For the function's inputs
.OUTPUTS
ToDo: write Help For the function's outputs
.EXAMPLE
ToDo: write Help For example 1 of using this function
$result = @();
("C:\Dropbox\ChocolateyPackageListBackup\NCAT-LTB1\chocoList.txt", "C:\Dropbox\ChocolateyPackageListBackup\UTAT022\chocoList.txt", "C:\Dropbox\ChocolateyPackageListBackup\UTAT01\chocoList.txt") | %{$result += Get-ChocolatyPackagesFromProgramsList $_}
$result = $result | Select-Object -Property Name  | ?{$_.Name -notmatch '.commandline|.install|.portable' }  | Sort-Object -Property Name -uniq`
$yaml = Convertto-yaml  $result
$yaml = $yaml -replace '^','  '
set-content -Path C:\Dropbox\whertzing\GitHub\ATAP.IAC\rawchocopackages.yml -Value $yaml
gc C:\Dropbox\whertzing\GitHub\ATAP.IAC\rawchocopackages.yml
.EXAMPLE
ToDo: write Help For example 2 of using this function
.EXAMPLE
ToDo: write Help For example 2 of using this function
.LINK
ToDo
.LINK
ToDo: insert link to internet articles that contributed ideas / code used in this function e.g. http://www.somewhere.com/attribution.html
.SCM
ToDo: insert SCM keywords markers that are automatically inserted <Configuration Management Keywords>
#>
Function Get-ChocolatyPackagesFromProgramsList {
  [CmdletBinding()]
  Param (
    [Parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
    # ToDo: add validation script to ensure proper keys and values exists
    [ValidateNotNullOrEmpty()]
    $Path
    # , [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
    # [int[]] $FieldBreakCharacterLocations
    # , [Parameter(ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
    # [switch] $PublicOnly
  )
  #region BeginBlock
  BEGIN {
    # $DebugPreference = 'SilentlyContinue' # Continue SilentlyContinue
    # $VerbosePreference = 'SilentlyContinue' # Continue SilentlyContinue
    Write-PSFMessage -Level Debug -Message 'Entering Function %FunctionName% in module %ModuleName%' -Tag 'Trace'
    $REPattern = "^(?<Name>\S+)\s+(?<Version>\S+)\s*$"
    $allPackages = @()
    $leftovers = @()

  }
  #endregion BeginBlock
  #region ProcessBlock
  PROCESS {
    # $allLines = @()
    $lines += Get-Content -Path $Path
    # $trimmedAllLines = $($allLines | Where-Object { ($_ -notmatch '^\s*$') -and ($_ -notmatch 'generated by choco-package-list-backup') -and ($_ -notmatch '----') -and ($_ -notmatch 'DisplayName.+DisplayVersion.+Publisher') }) | Sort-Object
    for ($i = 0; $i -lt $lines.count; $i++) {
      if ($lines[$i] -imatch $REPattern) {
        $allPackages += [PSCustomObject] @{
          Name    = $($matches['Name']).Trim()
          Version = $($($matches['Version']).Trim()) -replace '"','' # sometimes the version is surrounded by double-apostrophe character, have to remove it
        }
      }
      else {
        $leftovers += $lines[$i]
      }
    }
  }
  #endregion ProcessBlock
  #region EndBlock
  END {
    Write-PSFMessage -Level Debug -Message 'Leaving Function %FunctionName% in module %ModuleName%' -Tag 'Trace'
# ToDo: if leftovers are not empty, return the data in a structure along with the allpackages structure list
    $allPackages

  }
  #endregion EndBlock
}
#endregion Get-ChocolatyPackagesFromProgramsList
